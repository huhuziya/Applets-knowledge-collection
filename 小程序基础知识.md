### 开发前工作准备
1.[框架wepy开发文档](https://cloud.tencent.com/developer/article/1005018)

2.安装使用wepy
```
npm install wepy-cli -g //安装wepy框架
wepy init standard myproject    //初始化项目
cd myproject
npm install //安装npm
wepy build --watch  //开启实时编译
```
3.sass 编译器配置
```
npm install node-sass
npm install wepy-compiler-sass --save-dev
```
4.gitignore配置
#+要忽略的文件夹、文件

5.[框架mpvue](http://mpvue.com/mpvue/)

6.AppID(小程序ID)

AppSecret(小程序密钥)

### 小程序原生框架构成

##### 主体部分+各个页面
    app框架--主体部分：
        app.js：小程序逻辑，初始化app
        app.json：小程序配置，如导航、窗口、http请求
        app.wxss：公共样式配置
    page业务层--各个页面：
        js：逻辑控制
        wxml：结构展示
        wxss：样式
        json：页面配置

### 表单知识点
1.实时监听input输入组件
```
bindinput="inputPhoneNum"
inputPhoneNum(e) {
    this.phoneNum = e.detail.value
    this.$apply()
}

```
2.input属性
confirm-type属性定义右下角按钮的文本（在Android上测试无效）
auto-focus:true
    类型：Boolean
    自动聚焦，拉起键盘。如果你设置为true,那边你打开页面就会弹出键盘，这时可能会遮挡一些控件。
    此功能即将废弃，尽量使用focus
focus:
    类型：boolean
    获取焦点


### prop知识点
1.数据双向绑定 twoway:true
2.父组件一定要有的格式：syncTitle.sync = "parentTitle"
```
props = [
    status:{
        type:Number,
        twoway:true，
        default:0
    }
]
```

### 点击按钮触发样式改变
//hover-class
```
 <view 
    wx:if="{{send||phoneStatus}}" 
    class="sendMsg" 
    hover-class="active" 
    @tap="sendMsg()"
>获取验证码</view>   
.active{
    background-color: #d43d4d;
}
```

### 生命周期

1.onLoad：页面初始化
2.onReady：页面渲染完成
3.onShow：页面显示
4.onHide：页面隐藏
5.onUpload：页面关闭

### 事件绑定
```
<text wx:if="{{ isTextShow }}">{{  text  }}</text>
<button type="primary" btntap="btnClick">{{ btnText }}</button>
page({
    data:{
        text:"初始内容",
        btnText:"按钮内容",
        isTextShow:"true",
    },
    btnClick:function(){
        this.setData({btnText:"按钮被点击过了"})
        var isShow = this.data.isTextShow
        this.setData({text:"点击按钮，text内容修改了",isTextShow:!isShow})
    }
})
```
//子组件：
```	
<li
    class="tab-item"
    wx:for="{{tabs}}" wx:key="index" index="index" item="item"
    :class="{ active: currentTab == item.value }"
    @tap="clickTab({{item.value}})"
>
   {{ item.title }}
</li>
methods = {
	clickTab(_value) {
	this.currentTab = _value;
	console.log(_value)
	this.$emit('tabClick', _value);
   },
}
```
//父组件：
```
events = {
    tabClick(val){
        console.log(1)
        this.value = val
        this.$apply()
    }
}
//无需再再标签里面写@tabClick="handleClick"
```
### for循环
```
<view wx:for="{{ news }}" wx:for-item="newsItem">
    {{ index }}:{{ newsItem }}
</view>
```

### 页面
1.页面间的跳转
```
//跳转后可返回（先调用index生命周期方法onhide，再调用logs页面的onload--onshow--onready）
itemClick:function(){
    wx.navigateTo({
        url:'../logs/logs'
    })
}
//跳转后不可返回,index页面被销毁（先调用index生命周期方法onhide--onupload，再调用logs页面的onload--onshow--onready）
itemClick:function(){
    wx.redirectTo({
        url:'../logs/logs'
    })
}
//页面跳转
this.$root.$navigate('../../page/activity/index', {
    plan_id: info.plan_id,
    award_id: info.award.id
 })
```

2.页面间的参数传递

```
wx:navigate({
    url:"../logs/logs?id=1&title=标题abc"
})
//logs页面中onload中通过options传入的参数id和title
onLoad:function(options){
    this.articleId:options = id
    this.pageTitle:options = title
}
```

### wepy框架知识点

#### 声明
```
引入：import wepy from 'wepy'

//声明一个app小程序实例
export default class MyApp extend wepy.app{}

//声明一个page页面实例
export default class IndexPage extend wepy.page{}

在page页面可通过this.$parent来访问app实例

methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法
普通自定义方法于methods同级

//声明一个component组件实例
export default class MyComponent extend wepy.component{}
组件的所有业务功能都在组件内开发
```
#### 组件引用
```
<template>
    <repeat for="{{ list }}" key="index" index="index" item="item">
        <child :item="item"></child>
    </repeat>
</template>
<script>
import wepy from 'wepy';
import Child from '../components/child';

    export default class Index extends wepy.component {
        //声明组件，分配组件id为child
        components = {
            child: Child
        };
    }
</script>
```
#### 组件间的通信
```
this.$emit('some-event',1,2,3,4);
    events = {
        'some-event':(p1,p2,p3,$event)=>{
        console.log(``)
    }
}
$broadcast:由父组件发起的，经广度优先顺序搜索
$emit：从子组件依次发送给其父组件
$invoke:是一个页面或组件对另一个组件中的方法的直接调用
this.$invoke('ComA', 'someMethod', 'someArgs');
```
#### 组件自定义事件处理函数
```
页面：

<child @childFn.user="parentFn"></child>
 methods = {
    parentFn (num, evt) {
    console.log('parent received emit event, number is: ' + num)
    }
}

子组件：

<view @tap="tap">Click me</view>
tap () {
    console.log('child is clicked')
    this.$emit('childFn', 100)
}
```
#### 长按保存 
```
 preview(src){
    wx.previewImage({
        current: src, // 当前显示图片的http链接
        urls: [src] // 需要预览的图片http链接列表
    })
  }  
```
#### wepy的组件里只有一个view标签的视图、不能包含其他组件！！

```
//错误写法：
<template>
    <view>
    ....
    </view>
    <ApplyEntrance></ApplyEntrance>
</template>

//正确写法：
<template>
    <view>
        ....
        <ApplyEntrance></ApplyEntrance>
    </view>
</template>
```
#### 行内样式书写规范
```
style="transform: translateX({{idx * 100}}%)"（坑 ：不要用this.dix）
style="background-color:{{item.bg_color}}"
```

#### 数据传值prop只能传两层，第三层要加一个数组包含起来
```
<view class="detail">
		<repeat for="{{[info]}}"
            item="item"
            index="index"
            key="key">
            <view class="detail-item">
                <SliderShow :res.sync="item"></SliderShow>
            </view>
        </repeat>
</view>

//不要直接使用以下写法
<view class="detail">
    <SliderShow :res.sync="item"></SliderShow>
</view>
```

#### 轮播图点击事件出现同步控制 
```
//讲点击改变的数据传到父组件，改变最初请求的数据达到控制目的
//repeat一个子组件，child子组件有一个tap事件（让一段文字变色），点击事件所有子组件都会变色

组件是在编译阶段编译进页面的，每个组件都是唯一的一个实例，目前只提供简单的 repeat 支持。
不支持在 repeat 的组件中去使用 props, computed, watch 等等特性
```
```
<!-- 错误使用 -->
// list.wpy
<view>{{test.name}}</view>

// index.wpy
<repeat for="{{mylist}}">
   <List :test.sync="item"></List>
</repeat>

<!-- 推荐用法 -->
// list.wpy
<repeat for="{{mylist}}">
    <view>{{item.name}}</view>
</repeat>

// index.wpy
<List :mylist.sync="mylist"></List>
```

//例子：

//slidershow子组件
```
<view class="left-wrap btn-wrap" @tap="left({{res}})" wx:if="{{res.idx>0}}">
    <view class="btn-left buttons">
        <image src="" class="left-pic pic"/>
    </view>
</view>
```

//redemm组件
```
<SliderShow :res.sync="item"
    :numbers.sync="numbers"
    @changeIdx.user="changeIdx"
    @changeNum.user="changeNum"
></SliderShow>
changeIdx(res, method) {
    this.$emit("changeIdx", res, method)
}
```

//home页
```
<view class="component-redemm-wrap">         <Redemm:info.sync="item":total.sync="info"@changeIdx.user="changeIdx" ></Redemm>
</view>
changeIdx(res, method) {
  if (method === "plus") {
    this.info.activities[res.index].idx =
      this.info.activities[res.index].idx + 1;
  } else {
    this.info.activities[res.index].idx =
      this.info.activities[res.index].idx - 1;
  }

  this.$apply();
},
```

### post和get方法
```
async sendGetTestReq() {
    let {data} = await this.$root.$parent.req.send({
        url: this.$root.$parent.req.api.test,
        data: Object.assign(this.$wxpage.options, {
            scene_id: this.$wxpage.options.scene_id	
            //query参数，接收从别的页面传递过来的query参数
        }),
        restful: {
            act_term_id: this.$wxpage.options.act_term_id	
            //必须参数。url的/{act_term_id}/index
        }
    })

    this.questions = data.questions
    this.next = data.next
    this.$apply()
}

let {data} = await this.$root.$parent.req.send({
    url: this.$root.$parent.req.api.activity,
    method: 'get',
    data: Object.assign(this.$wxpage.options, {
        award_id: this.$wxpage.options.award_id	
        //query参数，接收从别的页面传递过来的query参数
   }),
 })
```